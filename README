

这个项目争取用navigation的方式写一遍

BaseNetworkApi
1.提供可扩展的OkhttpClientBuilder作为形参的抽象方法
2.提供可扩展的RetrofitBuilder作为形参的抽象方法
3.创建okhttpClient
4.接收Class<T>作为形参, 返回参数为T
NetworkApi
1.继承BaseNetworkApi
2.重写setOkhttpClientBuilder：添加缓存目录, cookieJar, 公共拦截器, 缓存拦截器, 日志拦截器, 超时时间 连接、读、写
3.重写setRetrofitBuilder: 添加gson转换
ApiService
创建ApiService懒汉式单例




一.缓存拦截器 CacheInterceptor
@Override public Response intercept(Chain chain) throws IOException {
    Response cacheCandidate = cache != null
        ? cache.get(chain.request())
        : null;
    //步骤1
    CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();

    //如果有缓存，更新统计指标, 增加命中率
    if (cache != null) {
      cache.trackResponse(strategy);
    }

    //步骤4
    //处理方式一
    //如果当前没有网络且找不到缓存
    if (networkRequest == null && cacheResponse == null) {
        return new Response.Builder()
          .request(chain.request())
          .protocol(Protocol.HTTP_1_1)
          .code(504)
          .message("Unsatisfiable Request (only-if-cached)")
          .body(Util.EMPTY_RESPONSE)
          .sentRequestAtMillis(-1L)
          .receivedResponseAtMillis(System.currentTimeMillis())
          .build();
    }

    //步骤5
    //处理方式二
    //如果不使用网络请求，直接返回缓存的Response
    if (networkRequest == null) {
        return cacheResponse.newBuilder()
          .cacheResponse(stripBody(cacheResponse))
          .build();
    }

    //步骤6
    //处理方式三
    //本地有缓存,服务器返回状态码为HTTP_NOT_MODIFIED(304),使用缓存数据
    if (cacheResponse != null) {
        if (networkResponse.code() == HTTP_NOT_MODIFIED) {
        Response response = cacheResponse.newBuilder()
            .headers(combine(cacheResponse.headers(), networkResponse.headers()))
            .sentRequestAtMillis(networkResponse.sentRequestAtMillis())
            .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())
            .cacheResponse(stripBody(cacheResponse))
            .networkResponse(stripBody(networkResponse))
            .build();
        networkResponse.body().close();

        // Update the cache after combining headers but before stripping the
        // Content-Encoding header (as performed by initContentStream()).
        cache.trackConditionalCacheHit();
        cache.update(cacheResponse, response);
        return response;
        } else {
        closeQuietly(cacheResponse.body());
        }
    }

    //步骤7
    //处理方式四
    //如果服务器资源已经修改，使用网络响应返回的最新数据
    Response response = networkResponse.newBuilder()
        .cacheResponse(stripBody(cacheResponse))
        .networkResponse(stripBody(networkResponse))
        .build();

    if (cache != null) {
      if (HttpHeaders.hasBody(response) && CacheStrategy.isCacheable(response, networkRequest)) {
        // Offer this request to the cache.
        CacheRequest cacheRequest = cache.put(response);
        return cacheWritingResponse(cacheRequest, response);
      }

      if (HttpMethod.invalidatesCache(networkRequest.method())) {
        try {
          cache.remove(networkRequest);
        } catch (IOException ignored) {
          // The cache cannot be written.
        }
      }
    }
    return response;

}

public CacheStrategy get() {
  //步骤2
  CacheStrategy candidate = getCandidate();

  if (candidate.networkRequest != null && request.cacheControl().onlyIfCached()) {
    // We're forbidden from using the network and the cache is insufficient.
    return new CacheStrategy(null, null);
  }

  return candidate;
}

//步骤3
private CacheStrategy getCandidate() {
  //找不到缓存，需要网络请求
  if (cacheResponse == null) {
    return new CacheStrategy(request, null);
  }

  // 如果是https请求且缺少握手操作，需要网络请求
  if (request.isHttps() && cacheResponse.handshake() == null) {
    return new CacheStrategy(request, null);
  }

  // 判断网络请求该不该缓存下来，不该缓存则，需要网络请求
  if (!isCacheable(cacheResponse, request)) {
    return new CacheStrategy(request, null);
  }


  // 如果指定不缓存或者是可选择的请求，需要网络请求
  CacheControl requestCaching = request.cacheControl();
  if (requestCaching.noCache() || hasConditions(request)) {
    return new CacheStrategy(request, null);
  }

  //上述需要网络请求返回的 CacheStrategy 第一个参数传入request

  //如果缓存是不受影响的，CacheStrategy传入cacheResponse
  CacheControl responseCaching = cacheResponse.cacheControl();
  if (responseCaching.immutable()) {
    return new CacheStrategy(null, cacheResponse);
  }


  //可以缓存，添加请求头信息
  if (!responseCaching.noCache() && ageMillis + minFreshMillis < freshMillis + maxStaleMillis) {
    Response.Builder builder = cacheResponse.newBuilder();
    if (ageMillis + minFreshMillis >= freshMillis) {
      builder.addHeader("Warning", "110 HttpURLConnection \"Response is stale\"");
    }
    long oneDayMillis = 24 * 60 * 60 * 1000L;
    if (ageMillis > oneDayMillis && isFreshnessLifetimeHeuristic()) {
      builder.addHeader("Warning", "113 HttpURLConnection \"Heuristic expiration\"");
    }
    return new CacheStrategy(null, builder.build());
  }

  ...
}

综上述:
一.如果当前没有网络且找不到缓存,返回504
二.如果当前没有网络，有本地缓存,直接返回缓存的Response
三.本地有缓存,服务器返回状态码为HTTP_NOT_MODIFIED(304),使用缓存数据
四.如果服务器资源已经修改，使用网络响应返回的最新数据

用代码表示
class LogInterceptor : Interceptor {
    override fun intercept(chain: Interceptor.Chain): Response {

        val request = chain.request()
        val response = chain.proceed(request)

        //第一种情况:没有网络，也没有缓存， 返回504
        if (response.cacheResponse() == null && !NetworkUtil.isNetworkAvailable(Utils.getApp())) {
            Log.i("WislieZhu", "504")
        }
        //第二种情况:没有网络，本地有缓存,使用本地缓存
        if (response.cacheResponse() != null && !NetworkUtil.isNetworkAvailable(Utils.getApp())) {
            Log.i("WislieZhu", "从缓存中获取数据")

        }
        //第三种情况:访问服务器资源，返回的状态码为304,本地有缓存,使用本地缓存
        if (response.cacheResponse() != null) {
            response.networkResponse()?.let { networkResponse ->
                if (networkResponse.code() == HttpURLConnection.HTTP_NOT_MODIFIED) {
                    Log.i("WislieZhu", "从缓存中获取数据 code=${networkResponse.code()}")
                }
            }
        }
        //第四种情况:访问服务器资源，资源发生变化,使用网络访问
        response.networkResponse()?.let {networkResponse ->
            if (networkResponse.code() != HttpURLConnection.HTTP_NOT_MODIFIED) {
                Log.i("WislieZhu", "从网络中获取数据 code=${networkResponse.code()}")
            }
        }

        return response
    }
}

二.是否缓存
public static boolean invalidatesCache(String method) {
    return method.equals("POST")
        || method.equals("PATCH")
        || method.equals("PUT")
        || method.equals("DELETE")
        || method.equals("MOVE");     // WebDAV
}
如果请求的method 是post,patch,put,delete,move 那么okhttp不作缓存

三.Response.Build中addHeader和header的区别

List<String> namesAndValues = new ArrayList<>(20);
addHeader:
public Builder addHeader(String name, String value) {
  headers.add(name, value);
  return this;
}
public Builder add(String name, String value) {
  checkName(name);
  checkValue(value, name);
  return addLenient(name, value);
}
Builder addLenient(String name, String value) {
  namesAndValues.add(name);
  namesAndValues.add(value.trim());
  return this;
}
header:
public Builder header(String name, String value) {
  headers.set(name, value);
  return this;
}
public Builder set(String name, String value) {
  checkName(name);
  checkValue(value, name);
  removeAll(name);
  addLenient(name, value);
  return this;
}
public Builder removeAll(String name) {
  for (int i = 0; i < namesAndValues.size(); i += 2) {
    if (name.equalsIgnoreCase(namesAndValues.get(i))) {
      namesAndValues.remove(i); // name
      namesAndValues.remove(i); // value
      i -= 2;
    }
  }
  return this;
}

四.本地缓存添加方式:
客户端第一次请求网络时，服务器返回回复信息。如果数据正常的话，客户端缓存在本地的缓存目录。
当客户端再次访问同一个地址时，客户端会检测本地有没有缓存，如果有缓存的话，数据是有没有过期，如果没有过期的话则直接运用缓存内容
1.指定缓存目录
Cache(File(Utils.getApp().cacheDir, "xx_network_cache")
android 10.0及以上的需要做存储兼容适配, 为了适配不同的android版本, 使用cacheDir
2.Cache-Control
是由服务器返回的Response中添加的头信息，它的目的是告诉客户端是要从本地读取缓存还是直接从服务器摘取消息
FORCE_NETWORK 强制使用网络请求
FORCE_CACHE 只取本地的缓存
private 客户端可以缓存
public  客户端和代理服务器都可以缓存
max-age=xxx 缓存数据在xxx秒后过期


五.addNetworkInterceptor和addInterceptor的区别
addInterceptor
1.有无网络都会被调用到
2.addInterceptor() 方法添加的拦截器是放在最前面

addNetworkInterceptor
1.无网络时不会被调用
2.在非 WebSocket 请求时，添加在 ConnectInterceptor 和 CallServerInterceptor 之间的, 也就是在发起请求和响应之间

六.Http不同的状态码
1XX Informational(信息性状态码) 接收的请求正在处理
2XX Success(成功状态码) 请求正常处理完毕
3XX Redirection(重定向状态码) 需要进行附加操作以完成请求
4XX ClientError(客户端错误状态码) 服务器无法处理请求
5XX ServerError(服务端错误状态码) 服务器处理请求出错
 200: '服务器成功返回请求的数据。'
 201: '新建或修改数据成功。'
 202: '一个请求已经进入后台排队（异步任务）。'
 204: '删除数据成功。'
 400: '发出的请求有错误，服务器没有进行新建或修改数据的操作。'
 401: '用户没有权限（令牌、用户名、密码错误）。'
 403: '用户得到授权，但是访问是被禁止的。'
 404: '发出的请求针对的是不存在的记录，服务器没有进行操作。'
 406: '请求的格式不可得。'
 410: '请求的资源被永久删除，且不会再得到的。'
 422: '当创建一个对象时，发生一个验证错误。'
 500: '服务器发生错误，请检查服务器。'
 502: '网关错误。'
 503: '服务不可用，服务器暂时过载或维护。'
 504: '网关超时。'

七.GET请求与Post请求区别
 post:
 post请求会把前端html表单中的所有数据放到Request body，用户无法直接观察到
 post请求不会缓存
 post请求不会把数据直接暴露在URL键值对中，所以适合处理敏感数据，如密码、金额等
 post请求没有参数长度的限制，所以支持更多更大的数据包
 post请求接受参数数据类型没有限制
 get:
 get请求把参数数据队列加到前端html提交表单的action属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到
 get请求会把数据直接暴露在URL键值对中，所以不适合处理敏感数据，如密码、金额等
 get请求可被缓存，浏览器回退时则是无害的，因为已被缓存，不会再次重复提交请求
 get请求只接受参数数据类型为ASCII字符
 get请求会限制参数长度，如超出限制长度则无法发出请求

综上述:
post请求只应当用于处理数据(传送数据)，而不适用于获取数据;
get请求只应当用于取回数据(获取数据)，而不适用于传送数据;

待理解的问题
1.没看出addNetworkInterceptor重定向的问题
2.拦截器的添加顺序
3.okhttp是长连接还是短连接


1.文件存储适配


协程
delay() 非阻塞

GlobalScope启动的协程无法使进程保持活动状态，它们就像守护线程, 当主线程的执行完, 协程作用域GlobalScope内的函数也会执行完
协程是轻量级的，不像线程一样容易发生内存不足
可以抽取launch内部的代码块作为一个独立的函数，需要声明为挂起函数
runBlocking 是一个普通函数, runBlocking方法会阻塞当前线程, coroutineScope是一个挂起函数
协程取消 job.cancel, cancelAndJoin的结合



继续看okhttp
https://juejin.cn/post/6844903752424488974


------性能优化------
冷启动：后台没有我们的进程了(手动干掉或者系统回收了)，点击桌面的app应用图标启动



一定要尝试:一半布局一半compose-ui

databinding中lib和app的包名不能一致


1.主页
请求到数据
将数据显示到recyclerview
点击存在问题
刷新和加载更多, 还有分页，空白页
asm点击次数控制

FATAL EXCEPTION: main
Process: com.wislie.wanandroid, PID: 20592
retrofit2.HttpException: HTTP 504 Unsatisfiable Request (only-if-cached)

1.状态栏




https://github.com/hongyangAndroid/FlowLayout


android 启动动画
1.依赖
2.主题适配
android11及以下
<!-- android11及以下的启动动画适配 -->
<style name="MySplashTheme" parent="Theme.SplashScreen">
    <item name="windowSplashScreenBackground">@color/purple_500</item>
    <item name="windowSplashScreenAnimatedIcon">@mipmap/ic_launcher</item>
    <item name="windowSplashScreenAnimationDuration">200</item>
    <item name="postSplashScreenTheme">@style/SplashAppTheme</item> <!-- 必须 -->
</style>

<style name="SplashAppTheme" parent="Theme.MaterialComponents.DayNight.NoActionBar">
    <item name="colorPrimary">@color/purple_500</item>
    <item name="colorPrimaryDark">@color/purple_500</item>
    <item name="colorAccent">@color/purple_500</item>
</style>

android12及以上
<!-- android12启动动画适配 -->
<style name="MySplashTheme" parent="Theme.SplashScreen">
    <item name="android:windowSplashScreenBackground">@color/purple_500</item>
    <item name="android:windowSplashScreenAnimatedIcon">@mipmap/ic_launcher</item>
    <item name="android:windowSplashScreenAnimationDuration">200</item>
    <item name="android:windowSplashScreenIconBackgroundColor">@color/purple_500</item>
    <item name="postSplashScreenTheme">@style/SplashAppTheme</item> <!-- 必须 -->
</style>

<style name="SplashAppTheme" parent="Theme.MaterialComponents.DayNight.NoActionBar">
    <item name="colorPrimary">@color/purple_500</item>
    <item name="colorPrimaryDark">@color/purple_500</item>
    <item name="colorAccent">@color/purple_500</item>
</style>

3.启动的activity
需要在super.onCreate方法前调用 installSplashScreen()


LeakCanary的工作原理
将activity包装到weakreference中,如果weakreference包装过的activity被回收，该weakreference引用会被放到ReferenceQueue中, 监测ReferenceQueue检查activity是否能够被回收
常见的内存泄漏:
1.fragment
第一点:Fragment.onDestroyView() 的时候没有去清除和view相关的变量
第二点:将activity对象作为Context
第三点:注册之后忘记 解除注册(比如rxjava, 广播)




1.click只能点击一次
2.底部虚拟导航栏
3.还有没有网络的提示
4.navigation 传参
5.没有网络的情况下加载列表, 有没有报错的提示
6.网址列表错误的时候一直显示加载中
7.网址列表其中一个取消收藏，刷新后原本应该3个item, 结果只展示2个item


解决的问题有:
1.那个页面加载，那个页面消失
2.PageDataAdapter 数据的修改
3.Paging3接口分页 有时初始的currentPage = 0 有时 currentPage = 1
4.Paging3加载中,加载更多,请重试没展示, 很大可能是布局写的文字默认和背景色一样，要根据bind时的LoadState做处理



自主看源码:
1.TextView 跑马灯实现原理






目标是没有网络点击不动 哈哈哈


PagingDataAdapter
https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650253490&idx=1&sn=2e82553e9d835b6544591abb9dc855b5&chksm=886359ddbf14d0cb8d18bd053ade2f1131e76cac930e27068cef881d3cc4b689734a6a2ce22c&scene=27





模拟器install apk的时候 提示 目标计算机拒绝连接
解决办法：1.w+r, 切换到sdk下的platform-tools目录
        2.adb kill-server
        3.adb start-server


@BindingAdapter(value = ["checkChange"])
fun checkChange(checkbox: CheckBox, listener: CompoundButton.OnCheckedChangeListener) {
    checkbox.setOnCheckedChangeListener(listener)
}
xml中
<CheckBox
bind:checkChange="@{click.onCheckedChangeListener}"/>
kotlin中
inner class ProxyClick {
    var onCheckedChangeListener =
                CompoundButton.OnCheckedChangeListener { buttonView, isChecked ->
                    mViewModel.isShowPwd.set(isChecked)
                }
}


////////////////////

@BindingAdapter(value = ["noRepeatClick"])
@JvmStatic
fun setOnClick(view: View, clickListener: () -> Unit) {
    clickListener.invoke()
}
xml中
<TextView
    bind:noRepeatClick="@{()-> click.login()}"/>
kotlin中
inner class ProxyClick {
    fun login() {

    }
}

BindingAdapter的value的元素a
xml标签中的bind:b
a和b必须一致

BindingAdapter的 clickListener: () -> Unit
xml中的()-> click.login()
两者也一致

BindingAdapter不支持有形参的高阶函数
TextInputEditText:

TextInputLayout:
1.改变startIcon的颜色
setStartIconTintList(ColorStateList.valueOf(color))
2.改变endIcon的颜色
setEndIconTintList(ColorStateList.valueOf(color))
3.控制endIcon是否可见
textInputLayout.isEndIconVisible = true/false



navigation的fragment返回问题
fragmentA->fragmentB->fragmentC->fragmentD
当前处于fragmentD
1.返回fragmentC
findNav().navigateUp()
2.返回fragmentB
findNav().popBackStack(R.id.fragment_b, false)
fragment_b 是 fragmentB在nav中的id
2.返回fragmentA
findNav().popBackStack(R.id.fragment_b, true)


1.拍照预览画面没出来
TextureView.setSurfaceTextureListener的onSurfaceTextureAvailable回调没走
原因: 清单文件中当前Activity没加硬件加速
2.前置摄像头和后置摄像头区别
Surface.ROTATION_0 的值不一样
CameraCharacteristics.LENS_FACING_BACK: 90
CameraCharacteristics.LENS_FACING_FRONT:270


LoadStateAdapter
https://www.cnblogs.com/mymy-android/p/14896898.html#tag5



1.android点击 弄成插件
2.会到第一页的速度过慢

kotlin
Sequences 序列的原理:
    Sequences 提升性能的关键在于多个操作共享同一个 Iterator 迭代器，只需要一次循环就可以完成数据操作
扩展函数的原理：
    扩展函数的语义是在不修改类 / 不继承类的情况下，向一个类添加新函数或者新属性。本质是静态函数，静态函数的第一个参数是接收者类型，调用扩展时不会创建适配对象或者任何运行时的额外消耗
apply、with 的 lambda 参数是 T 的扩展函数，因此在 lambda 内使用 this 引用接收者对象，而 let 的 lambda 参数是参数为 T 的高阶函数
委托机制的原理：
    Kotlin 委托的语法关键字是 by，其本质上是面向编译器的语法糖，三种委托（类委托、对象委托和局部变量委托）在编译时都会转化为 “无糖语法”.
    例如类委托：编译器会实现基础接口的所有方法，并直接委托给基础对象来处理。例如对象委托和局部变量委托：在编译时会生成辅助属性（prop$degelate），
    而属性 / 变量的 getter() 和 setter() 方法只是简单地委托给辅助属性的 getValue() 和 setValue() 处理
中缀函数： 声明 infix 关键字的函数是中缀函数，调用中缀函数时可以省略圆点以及圆括号等程序符号，让语句更自然
Array 和 IntArray 的区别： Array 相当于引用类型数组 Integer[]，IntArray 相当于数值类型数组 int[]
Byte、Short、Int、Long、Float、Double、Char 和 Boolean 大多数情况下，它们在编译后会变成基本数据类型，类型参数会被编译为引用类型
Kotlin 不存在隐式类型转换，即时是低级类型也需要显式转换为高级类型

init 函数执行顺序： 主构造函数 > init > 次级构造函数
内部类： Kotlin 默认为静态内部类，如果想访问类中的成员方法和属性，需要添加 inner 关键字称为非静态内部类
data 关键字原理： data 关键字用于定义数据类型，编译器会自动从主构造函数中提取属性并生成一系列函数：equals()/hashCode()、toString()、componentN()、copy()
sealed 关键字原理： 密封类用来表示受限的类继承结构，密封类可以有子类，但是所有子类都必须内嵌在该密封类中
object 与 companion object 的区别
    object 有两层语义：静态匿名内部类 + 单例对象
    companion object 是伴生对象，一个类只能有一个，代表了类的静态成员（函数 / 属性）
lambda 表达式本质上是「可以作为值传递的代码块」
lambda 表达式的种类
    1、普通 Lambda 表达式：例如 ()->R
    2、带接收者对象的 Lambda 表达式：例如 T.()->R
inline 内联函数的原理
    1.内联函数的参数如果是 lambda 表达式，则该参数默认也是 inline 的。lambda 表达式也会被固化的函数调用位置，
    从而减少了为 lambda 表达式创建匿名内部类对象的开销。当 lambda 表达式被经常调用时，可以减少内存开销
    2.减少入栈出栈过程（次要优点）： 内联函数的函数体被固化到函数调用位置，执行过程中减少了栈帧创建、入栈和出栈过程。
    需要注意：如果函数体太大就不适合使用内联函数了，因为会大幅度增加字节码大小

databinding 布局中 include 嵌套layout, 如果要要使用嵌套layout的子控件(假设childId)，需要
1.设置include 嵌套layout的 id  (假设includeLayoutId)
2.嵌套layout 也改造成databinding格式
3.activity/fragment中引用 layout的子控件  binding.includeLayoutId.childId

todo:
kotlin中 ArrayList与MutableList
MutableList 默认是 ArrayList
1.webFragment收藏与不收藏 反复请求, 前一页的变化
2.收藏页 取消收藏时, 首页的变化
3.收藏的文章列表  取消收藏后展示不对
4.有些不需要没有更多，加载中这些,只需要加载 比如体系，导航列表
5.bottom navigation 文字和图标同时变色
上述已搞定
1.我的(有很多东西需要改进)
2.asm onclick 拦截
3.背景色改变
4.换肤




Paging 生命周期
PagingSource->Pager->Flow<PagingData>->PagingDataAdapter



6.
编辑收藏的文章，支持站内，站外  lg/collect/user_article/update/ 文章 id/json
编辑收藏网站 lg/collect/updatetool/json
7.搜索 article/query/0/json
12.个人信息接口  user/lg/userinfo/json
13.问答评论列表 wenda/comments/问答id/json
14.未读消息数量 message/lg/count_unread/json
 已读消息列表 message/lg/readed_list/页码/json
 未读消息列表 message/lg/unread_list/页码/json
17.工具列表 tools/list/json
18.教程列表 chapter/547/sublist/json
单个教程下所有文章列表 list/0/json?cid=549&order_type=1



启动优化:
1.使用adb 命令查看耗时情况
adb shell am start -W [packageName]/[packageName.MainActivity]
adb shell am start -W com.wislie.wanandroid/com.wislie.wanandroid.activity.MainActivity
2.生成.trace文件, 用profiler分析
TopDown: 调用方耗时
BottomUp：被调用方耗时
Flame Chart 火焰图
3.减少启动页的布局层次
需要学习的优化方案:
1.ContentProvider


2月份计划
1.协程和Flow
2.Android适配方案
3.线程
其他: 如kotlin版玩Android, compose ui基础，巩固ASM等
内存抖动等知识
https://juejin.cn/post/6844904099998089230#heading-71


二月份playAndroid写了一些, 争取三月份前3天搞定; 协程有学习,但是还讲不出子丑寅卯, Android适配方案一点没看, 线程也是
接下来每天都要有实质性的进展

3月份计划

1.compose ui版玩Android
2.APT
3.android开源库理解和手写
其他:flutter基础, 设计模式, 单元测试等



4月份计划

1.flutter版玩Android

2.Android知识点整体复习完

3.算法了解











马士兵的深入理解 java 虚拟机和唐朔飞计算机组成原理

安装apk
adb install E:\android_workspace\wanAndroid\WanAndroid-Kotlin\app\release\app-release.apk