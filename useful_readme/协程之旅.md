加载到内存，被CPU运行为进程

CPU占用率指的是进程的占用率

定义进程: 操作系统进行资源分配的基本单位

进程之间内存隔离，无法轻易访问

进程1 进程2  进程3   加载到内存

CPU从内存中取出进程1，执行进程1；过会轮到进程2执行，依次下去轮到进程3执行



进程不能一直占用CPU到任务结束为止，需要规定占用的时间片，在规定的时间片内进程能完成多少是多少，时间一到立即退出CPU换另一个进程上，没能完成任务的进程等下个轮到自己的时间片再上



将进程划分为若干线程，这些线程共享进程的资源池，进程想要执行某任务直接交给线程即可，而CPU每次以线程为单位执行

定义线程:CPU分配资源的最小单位



android 异步调用：子线程执行耗时任务，获取结果后回调到主线程

Android主线程和子线程切换容易陷入多层回调，不利于阅读和调试

协程解决了异步编程时过多回调的问题

协程是线程框架，kotlin协程内部维护了线程池，无需关注线程的切换细节，只需指定想要执行的线程即可



"suspend"修饰的函数只能在协程里被调用或者是在另一个被"suspend"修饰的函数里调用

suspend 意为挂起，阻塞 

执行suspend函数时，表明协程可能会被挂起，挂起意味着协程将无法继续往下执行，直到条件满足恢复了协程的运行

1.协程的创建

2.协程调用

suspend 修饰的函数类型，其实参是匿名内部类，继承自抽象类：SuspendLambda

SuspendLambda 继承自ContinuationImpl

ContinuationImpl继承自BaseContinuationImpl

BaseContinuationImpl有两个方法**invokeSuspend(xx)与create(xx)**

协程的整体流程:

闭包生成匿名类：

1.实现Function1 接口, 实现接口中的invoke函数

2.继承了SuspendLambda，并重写了invokeSuspend函数和create函数

闭包执行:

3.创建协程**createCoroutine**

4.开启协程BaseContinuationImpl.resumeWith



**闭包生成的匿名内部类**

```java
class MyAnonymous extends SuspendLambda implements Function1 {
    int label;
    public final Object invokeSuspend(@NotNull Object var1) {
        Object var4 = IntrinsicsKt.getCOROUTINE_SUSPENDED();
        switch(this.label) {
            case 0:
                String var2 = "I am coroutine";
                boolean var3 = false;
                System.out.println(var2);
                return Unit.INSTANCE;
        }
    }
    public final Continuation create(@NotNull Continuation completion) {
        Intrinsics.checkNotNullParameter(completion, "completion");
        Function1 var2 = new <anonymous constructor>(completion);
        return var2;
    }
    public final Object invoke(Object var1) {
        return ((<undefinedtype>)this.create((Continuation)var1)).invokeSuspend(Unit.INSTANCE);
    }
}

public static final void launchFish(@NotNull MyAnonymous block) {
    Continuation coroutine = ContinuationKt.createCoroutine(block, (new Continuation() {
        @NotNull
        public CoroutineContext getContext() {
            return (CoroutineContext) EmptyCoroutineContext.INSTANCE;
        }

        public void resumeWith(@NotNull Object result) {
            String var2 = "result:" + Result.toString-impl(result);
            boolean var3 = false;
            System.out.println(var2);
        }
    }));
    //开启
    coroutine.resumeWith(Result.constructor-impl(var3));
}

public static final void main(@NotNull String[] array) {
    MyAnonymous myAnonymous = new MyAnonymous();
    launchFish(myAnonymous);
}
```

**闭包的执行**

#Continuation.kt
fun <T> (suspend () -> T).createCoroutine(
    completion: Continuation<T>
): Continuation<Unit> =
    //返回SafeContinuation 对象
    //SafeContinuation 构造函数需要2个参数，一个是delegate，另一个是协程状态
    //此处默认是挂起
    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)

#IntrinsicsJvm.kt
actual fun <T> (suspend () -> T).createCoroutineUnintercepted(
    completion: Continuation<T>
): Continuation<Unit> {
    val probeCompletion = probeCoroutineCreated(completion)
    return if (this is BaseContinuationImpl)
        //此处的this 即为匿名内部类对象 MyAnonymous，它间接继承了BaseContinuationImpl
        //调用MyAnonymous 重写的create 函数
        //create 函数里new 新的MyAnonymous 对象
        create(probeCompletion)
    else
        createCoroutineFromSuspendFunction(probeCompletion) {
            (this as Function1<Continuation<T>, Any?>).invoke(it)
        }
}

#IntrinsicsJvm.kt
public actual fun <T> Continuation<T>.intercepted(): Continuation<T> =
    //判断是否是ContinuationImpl 类型的Continuation
    //我们的demo里是true，因此会继续尝试调用拦截器
    (this as? ContinuationImpl)?.intercepted() ?: this

#ContinuationImpl.kt
public fun intercepted(): Continuation<Any?> =
    //查看是否已经有拦截器，如果没有，则从上下文里找，上下文没有，则用自身，最后赋值。
    //在我们的demo里上下文里没有，用的是自身
    intercepted
        ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)
            .also { intercepted = it }

**再看 resume()**

#SafeContinuationJvm.kt
actual override fun resumeWith(result: Result<T>) {
    while (true) { // lock-free loop
        val cur = this.result // atomic read
        when {
            //初始化状态为UNDECIDED，因此直接return
            cur === CoroutineSingletons.UNDECIDED -> if (SafeContinuation.RESULT.compareAndSet(this,
                    CoroutineSingletons.UNDECIDED, result.value)) return
            //如果是挂起，将它变为恢复状态，并调用恢复函数
           //demo 里初始化状态为COROUTINE_SUSPENDED，因此会走到这
            cur === COROUTINE_SUSPENDED -> if (SafeContinuation.RESULT.compareAndSet(this, COROUTINE_SUSPENDED,
                    CoroutineSingletons.RESUMED)) {
                //delegate 为之前创建的Continuation，demo 里因为没有拦截，因此为MyAnonymous
                delegate.resumeWith(result)
                return
            }
            else -> throw IllegalStateException("Already resumed")
        }
    }
}

#ContinuationImpl.kotlin
#BaseContinuationImpl类的成员函数
override fun resumeWith(result: Result<Any?>) {
    var current = this
    var param = result
    while (true) {
        probeCoroutineResumed(current)
        with(current) {
            val completion = completion!!
            val outcome: Result<Any?> =
                try {
                    //invokeSuspend 即为MyAnonymous 里的方法
                    val outcome = invokeSuspend(param)
                    //如果返回值是挂起状态，则函数直接退出
                    if (outcome === kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED) return
                    kotlin.Result.success(outcome)
                } catch (exception: Throwable) {
                    kotlin.Result.failure(exception)
                }
            releaseIntercepted() // this state machine instance is terminating
            if (completion is BaseContinuationImpl) {
                current = completion
                param = outcome
            } else {
                //执行到这，最终执行外层的completion，在demo里会输出"result:$result"
                completion.resumeWith(outcome)
                return
            }
        }
    }
}



如果协程体是主线程，第二协程体是子线程，那么第二协程体执行完，后续执行的还是主线程；

如果协程体是子线程1，第二协程体是子线程2，那么第二协程体执行完，后续执行的不一定是子线程1



挂起协程

delay, 而不是sleep

协程的魅力: 异步代码用同步的方式表示



withContext()函数恢复父协程的原理:

调用withContext()时传入父协程的协程体。

当withContext()的协程体执行完毕后会判断completion。

completion 即为1的协程体包装类：DispatchedCoroutine。

completion.resumeWith() 最后执行invokeSuspend()，通过状态机流转执行之前挂起逻辑之后的代码。

整个父协程体就执行完毕了。



不用withContext如何挂起协程:

方式一.delay

方式二.



协程切换线程：

1.withContext(Dispatchers.IO){}

2.withContext(Dispatchers.Default){}

3.withContext(Dispatchers.Main){}



协程分发器:

Dispatchers.IO 侧重于任务本身是阻塞型的，比如文件、数据库、网络等操作，此时是不怎么占用CPU的

Dispatchers.Default 侧重于计算型的任务，可能会长时间占用CPU



相比java线程池的优势:

减少线程频繁开启/关闭的资源消耗。

及时响应并执行任务。

较好地管控/监控 应用内的线程使用



java线程池:

1.核心线程+队列+非核心线程

2.首先使用核心线程执行任务，若是核心线程个数已满，则将任务加入到队列里，核心线程从队列里取出任务执行，若是队列已满，则再开启非核心线程执行任务

协程线程池原理:

> 1. 全局队列（阻塞+非阻塞）+ 本地队列。
> 2. IO 任务分发还有个缓存队列。
> 3. 线程从队列里寻找任务（包括偷）并执行，若是使用IO 分发器，则超出限制的任务将会放到缓存队列里。
